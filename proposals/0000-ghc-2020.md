---
author: Alejandro Serrano
date-accepted: ""
ticket-url: ""
implemented: ""
---

This proposal is [discussed at this pull request](https://github.com/ghc-proposals/ghc-proposals/pull/0>).
**After creating the pull request, edit this file again, update the number in
the link, and delete this bold sentence.**

# GHC 2020

This proposal introduces a new "language version" `GHC2020`, which includes `Haskell2010` as defined by the Report and several extensions.

## Motivation

It has almost become a meme that any slightly-complex Haskell module starts with a dozen lines of `{-# LANGUAGE #-}` pragmas. This poses several problems:

- beginners often see features behind an extension as "advanced" or "obscure", even though some like `LambdaCase` or `NamedFieldPuns` are quite simple;
- some sorts of programming in Haskell -- mostly type-level oriented -- require enables lots of extensions (think of the usual combo `MultiParamTypeClasses` + `FlexibleInstances` + `FlexibleContexts`). Sometimes the fact that there are different extensions, instead of a single `ExtendedTypeClasses` is mostly historical.

## Proposed Change Specification

We propose to introduce a new "language version" `GHC2020`, which extends `Haskell2010` with some default extensions. In order to characterize which extensions should be included, we have defined a set of six criteria:

1. The extension is (mostly) _conservative_: All programs that were accepted without the extension remain accepted, and with the same meaning.
2. _New failure modes_ that become possible with the extension are _rare_ and/or easy to diagnose. These failure modes include new error messages, wrong inferred types, and runtime errors, for example.
3. The extensions _complement_ the design of standard Haskell.
4. The extension has been -- and can reasonably be predicted to remain -- _stable_.
5. The extension is _not_ to _gate-keep_ an advanced or potentially-unsafe feature.
6. The extension has _widespread_ usage.

The list of [current extensions](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html) follows. Those deprecated or in process of deprecation, or relate to FFI, are not included.

### Satisfy all criteria

- `BangPatterns`
- `BinaryLiterals`
- `BlockArguments`
- `ConstrainedClassMethods`
- `ConstraintKinds`
- `DefaultSignatures`
- `DeriveAnyClass`
- `DeriveDataTypeable`
- `DeriveFoldable`
- `DeriveFunctor`
- `DeriveGeneric`
- `DeriveLift`
- `DeriveTraversable`
- `DerivingStrategies`
- `EmptyDataDecls`
- `EmptyDataDeriving`
- `ExistentialQuantification`
- `ExplicitForAll`
- `FlexibleContexts`
- `FlexibleInstances`
- `GeneralisedNewtypeDeriving`
- `HexFloatLiterals`
- `ImportQualifiedPost`
- `InstanceSigs`
- `KindSignatures`
- `MultiParamTypeClasses`
- `NegativeLiterals`
- `NumDecimals`
- `NumericUnderscores`
- `RankNTypes`
- `StandaloneDeriving`
- `TypeApplications`
- `TypeSynonymInstances`
- `ViewPatterns`

### Fail some criteria, but should be granted an exception

| Extension | 1 | 2 | 3 | 4 | 5 | 6 |
|-|-|-|-|-|-|-|
| `PolyKinds` | | | ❌ | |  | |
| `ScopedTypeVariables` | | | ❌ | |  | |
| `TypeOperators` | | | ❌ | |  | |

- `PolyKinds`: `data Proxy a = Proxy` has a different meaning with it on.
- `TypeOperators`: term-level operators are like lower-case identifiers, while type-level operators are like upper-case identifiers.

### In discussion

- `DataKinds`
- `DerivingVia`
- `FunctionalDependencies`
- `GADTs`
- `GADTSyntax`
- `MagicHash`
- `MonadFailDesugaring`
- `NamedWildCards`
- `PackageImports`
- `PartialTypeSignatures`
- `PostfixOperators`
- `QuantifiedConstraints`
- `RecordWildCards`
- `RoleAnnotations`
- `TypeFamilies`

### Fail some criteria

| Extension | 1 | 2 | 3 | 4 | 5 | 6 |
|-|-|-|-|-|-|-|
| `AllowAmbiguousTypes` | | | | | ❌ | |
| `ApplicativeDo` | ❌ | | ❌ | ❌ | | |
| `Arrows` | | | | ❌ | | |
| `CPP` | | | | | ❌ | |
| `DisambiguateRecordFields` | | | | ❌ | | |
| `DuplicateRecordFields` | | | | ❌ | | |
| `EmptyCase` | | ❌ | ❌ | | | |
| `ExplicitNamespaces` | ❌ | | | ❌ | | |
| `ImplicitParams` | | | ❌ | | | |
| `ImpredicativeTypes` | | | | | ❌ | |
| `IncoherentInstances` | | | | | ❌ | |
| `LambdaCase` | | | | ❌ | | |
| `LiberalTypeSynonyms` | | | | | ❌ | |
| `MonadComprehensions` | | | | | | ❌ |
| `MultiWayIf` | | ❌ | ❌ | ❌ | | |
| `NamedFieldPuns` | | ❌ | | | | |
| `OverlappingInstances` | | | | | ❌ | |
| `OverloadedLabels` | | | | ❌ | | |
| `OverloadedLists` | | ❌ | | | | |
| `OverloadedStrings` | | ❌ | | | | |
| `ParallelListComp` | | | | | | ❌ |
| `PatternSynonyms` | | | | ❌ | | |
| `QuasiQuotes` | | | | | ❌ | |
| `RebindableSyntax` | ❌ | | | | |
| `RecursiveDo` | | | | | | ❌ |
| `StandaloneKindSignatures` | | | | ❌ | | 
| `StaticPointers` | | | | | | ❌ |
| `Strict` | ❌ | | | | | |
| `StrictData` | ❌ | | | | | |
| `TemplateHaskell` | | | | | ❌ | |
| `TransformListComp` | | | | | | ❌ |
| `TupleSections` | | ❌ |
| `TypeFamilyDependencies` | | | | | | ❌ |
| `UnboxedSums` | | | | | | ❌ |
| `UnboxedTuples` | | | | | | ❌ |
| `UndecidableInstances` | | | | | ❌ | |
| `UndecidableSuperClasses` | | | | | ❌ | |
| `UnliftedNewtypes` | | | | | ❌ | |

- `EmptyCase`: `\x -> case x of {}` is strict in `x`. This is an exception to the general rule for `case` expressions, which are otherwise lazy (unless a pattern-match forces evaluation, of course).
- `LambdaCase` and `MultiWayIf`: new proposals are currently being discussed.
- `MultiWayIf`: `if |` now induces layout, in a different way than standard Haskell.
- `NamedFieldPuns`: almost always introduce shadowing, this extension turns a relatively benign typo into an obscure type error.
- `OverloadedLists` and `OverloadedStrings`: may bring more ambiguity.
- `StandaloneKindSignatures`: it misses information about arities for type families.

## Examples

This section illustrates the specification through the use of examples of the
language change proposed. It is best to exemplify each point made in the
specification, though perhaps one example can cover several points. Contrived
examples are OK here. If the Motivation section describes something that is
hard to do without this proposal, this is a good place to show how easy that
thing is to do with the proposal.

## Effect and Interactions

Your proposed change addresses the issues raised in the
motivation. Explain how.

Also, discuss possibly contentious interactions with existing language or compiler
features. Complete this section with potential interactions raised
during the PR discussion.


## Costs and Drawbacks

Give an estimate on development and maintenance costs. List how this effects
learnability of the language for novice users. Define and list any remaining
drawbacks that cannot be resolved.


## Alternatives

List alternative designs to your proposed change. Both existing
workarounds, or alternative choices for the changes. Explain
the reasons for choosing the proposed change over these alternative:
*e.g.* they can be cheaper but insufficient, or better but too
expensive. Or something else.

The PR discussion often raises other potential designs, and they should be
added to this section. Similarly, if the proposed change
specification changes significantly, the old one should be listed in
this section.

## Unresolved Questions

Explicitly list any remaining issues that remain in the conceptual design and
specification. Be upfront and trust that the community will help. Please do
not list *implementation* issues.

Hopefully this section will be empty by the time the proposal is brought to
the steering committee.


## Implementation Plan

(Optional) If accepted who will implement the change? Which other resources
and prerequisites are required for implementation?

## Endorsements

(Optional) This section provides an opportunty for any third parties to express their
support for the proposal, and to say why they would like to see it adopted.
It is not mandatory for have any endorsements at all, but the more substantial
the proposal is, the more desirable it is to offer evidence that there is
significant demand from the community.  This section is one way to provide
such evidence.

